# 03. 다른 객체 생성하기

> * 대른 객체 타입의 인스턴스 생성하기
> * 불완전한 객체 생성 막기
> * 도메인의 불변속성(invariant) 보호하기
> * 명명한 생성자 사용하기
> * 단언(assertion) 사용하기

객체에는 서비스와 값 객체, 두 종류가 있다. 더 구체적인 하위 종류, 즉 값 객체(value object)와 (때로는 모델이라고 하는) 개체로 나눌 수 있다.
서비스는 개체를 생성하거나 가져오며, 이를 조작하거나 다른 서비스에 전달한다. 값 객체는 서비스가 작업을 수행할 때 사용하는 재료가 된다.

## 3.1 일괄성 있는 행위에 필요한 최소한의 데이터를 요구한다.
* 행위에 필요한 데이터가 있어야 생성할 수 있게 강제해야 한다.
* 이는 생성를 사용해 **도메인 불변속성** 을 보호하는 방의 예다.
* **불변속성** 이란 주어진 객체가 나타내는 개념에 대한 도메인 지식을 바탕으로 그 객체에 대해 항상 참인 것이다.

## 3.2 의미있는 데이터를 요구한다.
* 클라언트가 의미 없는 데이터를 제공할 수도 있는지 항상 확인해야 한다.
* 의미없는 것으로 간주하는 것은 도메인 불변속성으로 표현할 수도 있다.
* 객체를 디자인할 때는 이러한 도메인 불변속성을 가이드로 삼아야 한다.

## 3.3 유효하지 않은 인자에 대한 예외로 사용자 정의 예외 클래스를 사용하지 않는다.
* 메서드 인자가 기대와 어긋날 때마다 일반적인 InvalidArgumentException 을 일으켰다.
* 유효하지 않은 인자는 클라이언트가 유효하지 않은 방법으로 객체를 사용한다는 의미다.
* 그럴 때는 철저히 실패해, 회복하려 들지 말고 그 실수를 고치는게 낫다.

> RuntimeException 은 종종 사용자 정의 예외 클래스를 사용하는 게 합당하다.
> 회복하거나 사용자 친화적인 오류 메시지로 변환할 수 있기 때문이다.

## 3.4 예외 메시지를 분석해 유효하지 않은 인자에 대한 특정 예외를 테스트한다.
단위 테스트에서 붙잡은 예외가 실제 기대한 것인지 항상 확인한다.

## 3.5 도메인 불변속성을 여러 곳에서 검증하지 않게 새 객체를 추출한다.
* 같은 클래스나 심지어 다른 클래스라도 종종 동일한 확인 논리를 반복하는 것을 볼 수 있다.
* **값 객체**라는 새로운 객체로 값을 감싸는 것은 유효성 확인 논리를 반복하지 않게 하는 데만 유용한게 아니다.즉
* 메서드가 기본 타입 값을 받아들인다는 것을 아는 즉시, 이에 대해 클래스를 도입하는 것을 고려해야 한다.
* 이를 위한 가이드 질문은 "string, int 같은 것이라면 무엇이든 받아들일 수 있는가?" 다. **답이 아니오** 라면 해당 개념을 위한 새로운 클래스를 도입한다.

## 복합 값은 새로운 객체로 추출해 나타낸다.





