# 서비스 생성하기

> * 서비스 객체의 인스턴스 생성하기
> * 의존성과 설정값을 주입하고 확인하기
> * 선택적인 생성자 인자를 필수 요소로 승격시키기
> * 암시적 의존성을 명시적으로 만들기
> * 서비스를 변경 불가능하게 디자인하기

## 2.1 객체의 두 종류
* 작업을 수행하거나 정보를 반환하는 `서비스 객체`
  * 한번 생성하면 여러 번 사용하지만 그 자신은 바꿀 수 없다.
* 생명 주기도 매우 단순하다. 한 번생성하면 특정 작업을 하는 기계처럼 영원히 실행할 수 있다.
* 데이터르 담고 있으며, 그 데이터를 조작하거나 가져오는 행위를 선택적으로 드려내는 객체
  * 서비스가 작동할 때 함께 하는 재료다.
  * 재료 객체의 생명주기는 서비스보다 더 복잡하다.

## 2.2 의존성과 설정값은 생성자 인자로 주입힌다.
흔히 서비스는 일을 처리하는데 다른 서비스가 필요하다. 그런 다른 서비스가 의존성이며, 생성자 인자로 주입한다.
```kotlin
interface Logger {
    fun log(message: String)
}

interface Formatter {
    fun format(message: String): String
}

class FileLogger (private val formatter: Formatter): Logger {
    // Formatter 에 의존한다.
    override fun log(message: String) {
        formatter.format(message)
        TODO("Not yet implemented")
    }
}
```
* 모든 의존성을 생성자 인자로 사용하게 하면 인스턴스 생성 즉시 서비스를 준비할 수 있다. 
* 추가 설정은 필요치 않으며 뜻하지 않게 의존성을 빠뜨릴 일도 없다.
* 파일 저장 위치나 외부 서비스 연결에 사용하는 증명 같은 것도 생성자 인자로 주입한다.
* ⚠️ 설정 객체 전체를 주입하지 말고 서비스에 필요한 값만 주입하자.

### 2.2.1 짝 지은 설정값은 함께 둔다
서비스에는 전역 설정 객체 전체가 아니라 필요한 값만 주입해야 한다.
어떤 값들은 항상 붙어다니기 때문에 따로따로 주입하면 자연스런 응집력을 망가뜨린다.
항상 붙어다니는 값은 전용 설정 객체를 도입해 함께 두는 것이 낫다.
```kotlin
// 따로따로 주입하는 경우
class AppClient(id: String, password: String)

// 항상 같이 다니는 값을 전용 설정 객체로 주입하는 경우 
class Credentials(id: String, password: String)

class AppClient(credentials: Credentials)
```

## 2.3 필요한 것의 위치가 아니라 필요한 것 자체를 주입한다.
> 서비스 위치 지정자란?  
서비스 위치 지정자는 그 자체로 서비스이며 다른 서비스를 가져올 수 있다.
* 서비스 위치 지정자는 응용 프로그램 내 사용 가능한 모든 서비스에 접근할 수 있기때문에 서비스 위치 지정자를 생성자 인자로 주입해 처리하려는 유혹이 있을 수 있다.
```kotlin
class HomepageController(locator: ServiceLocator) {
    fun execute(request:Request): Response {
        val user = locator.get(EntityManager::class)
            .getRepository(User::class)
            .getById(request.get("userId"))

        return locator.get(ResponseFactory::class)
          .create()
          .withContent(
              locator.get(TemplateRenderer::class)
                .render(user)
          )
    }
}
```
1. 결과적으로 코드에서 HomepageController 가 실제 어떤 일을 하는지 모호해진다.
2. 서비스를 의존성 주입을 하지 않았기 때문에 서비스를 가져오는 방법을 HomepateController 가 알아야 한다.
3. 서비스 위치 지정자를 통해 다른 많은 서비스에 접근할 수 있다.

이 모든 문제를 막기 위해서는 필요한 서비스를 명백히 의존성으로 선언하고 생성자 인자로 주입한다.
```kotlin
class HomepageController(
    userRepository: UserRepository, 
    responseFactory: ResponseFactory,
    templateRenderer: TemplateRenderer) {
    fun execute(request:Request): Response {
        val user = userRepository.getById(request.get("userId"))

        return responseFactory.create()
          .withContent(
              templateRenderer.render(user)
          )
    }
}
```
⚠️ 실제 의존성을 훨씬 더 정확히 볼 수 있다.


## 2.4 모든 생성자 인자는 필수여야 한다.
때로는 의존성 없이도 객체가 매우 잘 기능할 때도 있기때문에 의존성을 필수가 아닌 선택으로 두고 싶은 유횩이 생길 수 있다.
```kotlin
class BankStatementImporter(logger?: Logger) {
    fun import(bankStatementFilePath: String): Unit {
        // 때때로 디버깅을 위해 로그를 남긴다.
        if(logger is Logger) {
            // 로그를 남기기전에 인스턴스가 있는지 체크해야 한다
        }
    }
}
```
선택적 의존성으로 인해 생기는 문제를 이런 식으로 때우고 싶지 않다면 모든 의존성을 필수적인 것으로 해야 한다.
설정값도 마찬가지이다. 항상 클래스 사용자가 객체에 필요한 모든 설정값을 제공하게 해야 한다. 모든 클래스에 대해 이렇게 한다면 인스턴스를 만드는 방법을 보고 그 객체가 어떻게 구성되어 있는지 간단히 알 수 있다.

## 2.5 생성자 주입만 사용한다.
생성자가 아닌 setter 를 이용해 의존성을 주입할 수도 있다.
이 방식은 앞에서와 마찬가지로 코드가 복잡해지는 문제가 발생하며, 설정자 주입은 앞으로 다룰 두 가지 규칙도 위반한다.
* 객체를 불완전한 상태(incomplete state)로 생성할 수 없어야 한다.
* 서비스는 불변이어야 한다. 즉 인스턴스 생성을 마친 후에는 바꿀 수 없어야 한다.
간단히 말해서, 설정자 주입을 사용하지 말고 생성자 주입만 사용해라.

## 2.6 선택적인 의존성 같은 건 없다.
의존성은 필요하거나 그렇지 않거나, 둘 중 하나다.
그래도 정말로 부차적인 의존성(로거 같은?)이 필요하다고 생각하면 실제 객체처럼 보이는 대리 객체를 사용할 수 있다
```kotlin
class NullLogger: Logger {
    fun log(message: String): Unit {
        // do noting
    }
}
```
이런 무해한 객체를 흔히 더미(dummy) 또는 널 객체(null object) 라고 한다.